package main

import (
	"errors"
	"fmt"
)

type Bird interface {
	Sing() string
}

type Duck struct {
	voice string
}

func (d *Duck) Sing() string {
	return d.voice
}

func main() {
	var d *Duck
	song, err := Sing(d)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(song)
}

func Sing(b Bird) (string, error) {
	if b != nil {
		return b.Sing(), nil
	}
	return "", errors.New("Ошибка пения!")
}

/*
Значение указателя типа *Duck, присваемого переменной d будет nil, т.к. объект не инициализирован.
Т.к. структура Duck реализует интерфейс Bird, то она может передаваться в качестве параметра функции Sing(b Bird).
Когда переменной с типом интерфейса (Bird) присваивается значение, интерфейс внутренне указывает на тип (Duck) и значение данной переменной (nil).
Оба, тип интерфейса и значение должны быть типа nil для того чтобы переменная была равна nil.
Т.к. тип интерфейса не nil, проверка на nil проходит успешно и запускается метод Sing() для указанного типа (Duck).
Внутри метода пытается вернуть значение поля voice объекта типа Duck, но т.к. объект не существует, поле вернуть не представляется возможным.
Это вызывает панику.
Варианты решения:
1. инициализировать значение для переменной d с помощью &Duck{voice: "Quack"};
2. инициализировать значение для переменной d с помощью присвоения ей Duck{voice: "Quack"} для инициализации, а также в метод Sing() для этого типа также передавать не указатель, а значение типа Duck;
3. производить проверку значения этой переменной на nil после объявления переменной d в функции main
4. производить проверку значения этой переменной на nil в методе

В любом случае, для выполнения метода, необходимо инициализировать объект, для которого выполняется этот метод.
*/
